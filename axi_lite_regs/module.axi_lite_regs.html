<html>
<link rel="stylesheet" type="text/css" href="static/rustdoc.css">
<link rel="stylesheet" type="text/css" href="static/light.css">
<link rel="stylesheet" type="text/css" href="static/svdoc.css">
<body>
<section id="main" class="content"><h1 class="fqn">Module <a class="module">axi_lite_regs</a></h1>
<div class="docblock">
<p>AXI4-Lite Registers with option to make individual registers read-only.
This module exposes a number of registers on an AXI4-Lite bus modeled with structs.
It responds to accesses outside the instantiated registers with a slave error.
Some of the registers can be configured to be read-only.</p>
</div>
<h2 id="parameters" class="section-header"><a href="#parameters">Parameters</a></h2>
<h3 id="parameter.byte_t" class="impl"><code class="in-band">byte_t<span class="type-annotation">: type</span></code></h3><div class="docblock"
><p>DEPENDENT PARAMETER, DO NOT OVERWRITE! Type of a byte is 8 bits (constant).</p>
</div><h3 id="parameter.RegNumBytes" class="impl"><code class="in-band">RegNumBytes<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>The size of the register field in bytes mapped on the AXI4-Lite port.</p>
<p>The field starts at a <code>0x0</code> aligned address on the AXI and is continuous up to
address <code>0xNumbytes-1</code>. The module will only consider the LSBs of the address which fall into
the range <code>axi_req_i.ax.addr[$clog2(RegNumBytes)-1:0</code>. The other address bits are ignored.</p>
<p>The register indices <code>byte_index</code> of the register array are used to describe the functionality
of the other parameters and ports in regards to an individual byte mapped at <code>byte_index</code>.
A <code>chunk</code> is used to define the grouping of multiple registers onto the byte lanes of the
AXI4-Lite data channels.</p>
<p>The register bytes are mapped to the data lanes of the AXI channel as follows:
Eg: <code>RegNumBytes == 32'd11</code>, <code>AxiDataWidth == 32'd32</code></p>
<p>AXI strb:                           3 2 1 0 (AXI)
| | | |
<em>---------</em> | | |
<em>-------|-</em>-------|-* | |
| <em>-----|-|-</em>-----|-|-* |
| | <em>---|-|-|-</em>---|-|-|-*
| | |   | | | |   | | | |
<code>byte_index</code>:     A 9 8   7 6 5 4   3 2 1 0 (reg)
| chunk_2 | chunk_1 | chunk_0 |</p>
<p>If one wants to have holes in the address map/reserved bits the parameters/signals on the
ports <code>AxiReadOnly</code>, <code>ref_d_i</code>, <code>reg_q_o</code>, have to be defined accordingly.</p>
</div><h3 id="parameter.AxiAddrWidth" class="impl"><code class="in-band">AxiAddrWidth<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>Address width of <code>axi_req_i.aw.addr</code> and <code>axi_req_i.ar.addr</code>. Is used to generate internal
address map of the AXI4-Lite data lanes onto register bytes.</p>
</div><h3 id="parameter.AxiDataWidth" class="impl"><code class="in-band">AxiDataWidth<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>Data width of the AXI4-Lite bus. Register address map is generated with this value.
The mapping of the register bytes into chunks depends on this value.</p>
</div><h3 id="parameter.PrivProtOnly" class="impl"><code class="in-band">PrivProtOnly<span class="type-annotation">: bit</span></code></h3><div class="docblock"
><p>Privileged accesses only. The slave only executes AXI4-Lite transactions if the <code>AxProt[0]</code>
bit in the <code>AW</code> or <code>AR</code> vector is set, otherwise ignores writes and answers with
<code>axi_pkg::RESP_SLVERR</code> to transactions.</p>
</div><h3 id="parameter.SecuProtOnly" class="impl"><code class="in-band">SecuProtOnly<span class="type-annotation">: bit</span></code></h3><div class="docblock"
><p>Secure accesses only. The slave only executes AXI4-Lite transactions if the <code>AxProt[1]</code> bit
in the <code>AW</code> or <code>AR</code> vector is set, otherwise ignores writes and answers with
<code>axi_pkg::RESP_SLVERR</code> to transactions.</p>
</div><h3 id="parameter.AxiReadOnly" class="impl"><code class="in-band">AxiReadOnly<span class="type-annotation">: logic  [RegNumBytes-1:0]</span></code></h3><div class="docblock"
><p>This flag can specify a AXI4 read-only register at given <code>byte_index</code> of the register array.</p>
<p>This flag only applies for AXI4-Lite write transactions. The register byte can be loaded
directly by asserting <code>reg_load_i[byte_index]</code>. When <code>AxiReadOnly[reg_index] is set to 1'b1</code>,
the corresponding <code>axi_req_i.w.strb</code> signal is prevented to assert at the load signal of the
corresponding register byte address.</p>
<p>The B response will be <code>axi_pkg::RESP_OKAY</code> as long as at least one byte has been written,
even when partial byte write have been prevented by this flag! This is to allow the usage
of the full AXI bus width to write on read-only segmented fields.
When no byte has been written the module will answer with <code>axi_pkg::RESP_SLVERR</code>.</p>
<p>If one wants to constant propagate a byte in the register array:</p>
<ul>
<li>Set <code>AxiReadOnly[byte_index]</code> to 1'b1.</li>
<li>Set <code>reg_load_i[byte_index] constant to 1'b0. Then the byte at </code>reg_q_o[byte_index]<code>will be equal to</code>RegRstVal[byte_index]` and constant.</li>
</ul>
</div><h3 id="parameter.RegRstVal" class="impl"><code class="in-band">RegRstVal<span class="type-annotation">: byte_t [RegNumBytes-1:0]</span></code></h3><div class="docblock"
><p>Reset value for the whole register array.
Is an array of bytes with range <code>[RegNumBytes-1:0]</code>.</p>
</div><h3 id="parameter.req_lite_t" class="impl"><code class="in-band">req_lite_t<span class="type-annotation">: type</span></code></h3><div class="docblock"
><p>AXI4-Lite request struct. See macro definition in <code>include/typedef.svh</code>.
Is required to be specified.</p>
</div><h3 id="parameter.resp_lite_t" class="impl"><code class="in-band">resp_lite_t<span class="type-annotation">: type</span></code></h3><div class="docblock"
><p>AXI4-Lite response struct. See macro definition in <code>include/typedef.svh</code>.
Is required to be specified.</p>
</div><h3 id="parameter.AxiStrbWidth" class="impl"><code class="in-band">AxiStrbWidth<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
></div><h3 id="parameter.NumChunks" class="impl"><code class="in-band">NumChunks<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
></div><h3 id="parameter.ChunkIdxWidth" class="impl"><code class="in-band">ChunkIdxWidth<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
></div><h3 id="parameter.AddrWidth" class="impl"><code class="in-band">AddrWidth<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
></div><h3 id="parameter.RegByteIdx" class="impl"><code class="in-band">RegByteIdx<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
></div><h2 id="ports" class="section-header"><a href="#ports">Ports</a></h2>
<h3 id="port.clk_i" class="impl"><code class="in-band">clk_i<span class="type-annotation">: input  logic</span></code></h3><div class="docblock"
><p>Clock input signal (1-bit).</p>
</div><h3 id="port.rst_ni" class="impl"><code class="in-band">rst_ni<span class="type-annotation">: input  logic</span></code></h3><div class="docblock"
><p>Asynchronous active low reset signal (1-bit).</p>
</div><h3 id="port.axi_req_i" class="impl"><code class="in-band">axi_req_i<span class="type-annotation">: input  req_lite_t</span></code></h3><div class="docblock"
><p>AXI4-Lite slave port request struct, bundles all AXI4-Lite signals from the master.
This module will perform the write transaction when <code>axi_req_i.aw_valid</code> and
<code>axi_req_i.w_valid</code> are both asserted.</p>
</div><h3 id="port.axi_resp_o" class="impl"><code class="in-band">axi_resp_o<span class="type-annotation">: output resp_lite_t</span></code></h3><div class="docblock"
><p>AXI4-Lite slave port response struct, bundles all AXI4-Lite signals to the master.</p>
</div><h3 id="port.wr_active_o" class="impl"><code class="in-band">wr_active_o<span class="type-annotation">: output logic  [RegNumBytes-1:0]</span></code></h3><div class="docblock"
><p>Flag to tell logic that the AXI is writing these bytes this cycle. The new data
where <code>wr_active[byte_index] &amp;&amp; AxiReadOnly[byte_index] == 1'b0</code> is available in the
next cycle at <code>reg_q_o[byte_index]</code>. This signal is directly generated from the signal
axi_req_i.w.strb and is asserted regardless of the value of <code>AxiReadOnly</code>.</p>
<p>Is only active when the AXI prot flag from the channel has the right access permission.</p>
</div><h3 id="port.rd_active_o" class="impl"><code class="in-band">rd_active_o<span class="type-annotation">: output logic  [RegNumBytes-1:0]</span></code></h3><div class="docblock"
><p>Flag to tell logic that the AXI is reading the value of the bytes at <code>reg_q_o[byte_index]</code>
this cycle.</p>
<p>Is only active when the AXI prot flag from the channel has the right access permission.</p>
</div><h3 id="port.reg_d_i" class="impl"><code class="in-band">reg_d_i<span class="type-annotation">: input  byte_t [RegNumBytes-1:0]</span></code></h3><div class="docblock"
><p>Load value for each register. Can be used to directly load a new value into the registers
from logic.</p>
<p>If not used set to <code>'0</code>.</p>
</div><h3 id="port.reg_load_i" class="impl"><code class="in-band">reg_load_i<span class="type-annotation">: input  logic  [RegNumBytes-1:0]</span></code></h3><div class="docblock"
><p>Load enable for each register.
Each byte can be loaded directly by asserting <code>reg_load_i[byte_index]</code> to <code>1'b1</code>.
The load value from <code>reg_d_i[byte_index]</code> is then available in the next cycle at
<code>reg_q_o[byte_index]</code>.</p>
<p>If the load signal is active, an AXI4-Lite write transactions is stalled, when it writes onto
the same register chunk where at least one <code>reg_load_i[byte_index]</code> is asserted! It is
stalled until all <code>reg_load_i</code> mapped onto the same chunk are <code>'0</code>!</p>
<p>If not used set to <code>'0</code>;</p>
</div><h3 id="port.reg_q_o" class="impl"><code class="in-band">reg_q_o<span class="type-annotation">: output byte_t [RegNumBytes-1:0]</span></code></h3><div class="docblock"
><p>Register state output.</p>
</div><h2 id="types" class="section-header"><a href="#types">Types<a></h2>
<table>
<tr><td><a class="type" href="type.chunk_idx_t.html">chunk_idx_t</a></td><td></td></tr><tr><td><a class="type" href="type.addr_t.html">addr_t</a></td><td></td></tr><tr><td><a class="type" href="type.axi_rule_t.html">axi_rule_t</a></td><td></td></tr><tr><td><a class="type" href="type.axi_data_t.html">axi_data_t</a></td><td></td></tr><tr><td><a class="type" href="type.b_chan_lite_t.html">b_chan_lite_t</a></td><td></td></tr><tr><td><a class="type" href="type.r_chan_lite_t.html">r_chan_lite_t</a></td><td></td></tr></table>
<h2 id="signals" class="section-header"><a href="#signals">Signals</a></h2>
<h3 id="signal.aw_chunk_idx" class="impl"><code class="in-band">aw_chunk_idx<span class="type-annotation">: chunk_idx_t</span></code></h3><div class="docblock"
></div><h3 id="signal.b_chan" class="impl"><code class="in-band">b_chan<span class="type-annotation">: b_chan_lite_t</span></code></h3><div class="docblock"
></div><h3 id="signal.ar_chunk_idx" class="impl"><code class="in-band">ar_chunk_idx<span class="type-annotation">: chunk_idx_t</span></code></h3><div class="docblock"
></div><h3 id="signal.r_chan" class="impl"><code class="in-band">r_chan<span class="type-annotation">: r_chan_lite_t</span></code></h3><div class="docblock"
></div></section>
</body>
</html>
